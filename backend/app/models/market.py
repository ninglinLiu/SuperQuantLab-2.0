"""
Market data models: Candle, Bar, Order, Trade, Position, Portfolio
"""
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field


class Side(str, Enum):
    """Order side"""
    BUY = "BUY"
    SELL = "SELL"


class OrderType(str, Enum):
    """Order type"""
    MARKET = "MARKET"
    LIMIT = "LIMIT"


class OrderStatus(str, Enum):
    """Order status"""
    PENDING = "PENDING"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"


class Candle(BaseModel):
    """OHLCV candle/bar data"""
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    symbol: str = Field(default="BTCUSDT")
    timeframe: str = Field(default="1h")

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            Decimal: lambda v: float(v),
        }


class Bar(BaseModel):
    """Alias for Candle (used in strategy context)"""
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    symbol: str = Field(default="BTCUSDT")
    timeframe: str = Field(default="1h")

    @classmethod
    def from_candle(cls, candle: Candle) -> "Bar":
        """Convert Candle to Bar"""
        return cls(
            timestamp=candle.timestamp,
            open=candle.open,
            high=candle.high,
            low=candle.low,
            close=candle.close,
            volume=candle.volume,
            symbol=candle.symbol,
            timeframe=candle.timeframe,
        )

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            Decimal: lambda v: float(v),
        }


class Signal(BaseModel):
    """Trading signal generated by strategy"""
    timestamp: datetime
    symbol: str
    side: Side
    price: Decimal
    quantity: Optional[Decimal] = None  # None means use default position size
    reason: Optional[str] = None

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            Decimal: lambda v: float(v),
        }


class Order(BaseModel):
    """Order model"""
    order_id: str
    timestamp: datetime
    symbol: str
    side: Side
    order_type: OrderType
    quantity: Decimal
    price: Optional[Decimal] = None  # None for market orders
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: Decimal = Field(default=Decimal("0"))
    filled_price: Optional[Decimal] = None

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            Decimal: lambda v: float(v),
        }


class Trade(BaseModel):
    """Executed trade"""
    trade_id: str
    timestamp: datetime
    symbol: str
    side: Side
    quantity: Decimal
    price: Decimal
    fee: Decimal = Field(default=Decimal("0"))
    order_id: Optional[str] = None
    strategy_id: Optional[str] = None

    @property
    def value(self) -> Decimal:
        """Trade value (quantity * price)"""
        return self.quantity * self.price

    @property
    def net_value(self) -> Decimal:
        """Net value after fees"""
        return self.value - self.fee

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            Decimal: lambda v: float(v),
        }


class Position(BaseModel):
    """Position model"""
    symbol: str
    quantity: Decimal = Field(default=Decimal("0"))
    avg_price: Decimal = Field(default=Decimal("0"))
    current_price: Decimal = Field(default=Decimal("0"))
    unrealized_pnl: Decimal = Field(default=Decimal("0"))

    @property
    def value(self) -> Decimal:
        """Position value"""
        return abs(self.quantity * self.current_price)

    @property
    def is_long(self) -> bool:
        """Is long position"""
        return self.quantity > 0

    @property
    def is_short(self) -> bool:
        """Is short position"""
        return self.quantity < 0

    @property
    def is_flat(self) -> bool:
        """Is flat (no position)"""
        return self.quantity == 0

    def update_unrealized_pnl(self, current_price: Decimal) -> None:
        """Update unrealized PnL based on current price"""
        self.current_price = current_price
        if self.quantity != 0:
            cost_basis = self.quantity * self.avg_price
            current_value = self.quantity * current_price
            self.unrealized_pnl = current_value - cost_basis

    class Config:
        json_encoders = {
            Decimal: lambda v: float(v),
        }


class Portfolio(BaseModel):
    """Portfolio model"""
    initial_capital: Decimal
    cash: Decimal
    positions: dict[str, Position] = Field(default_factory=dict)
    equity: Decimal = Field(default=Decimal("0"))
    trades: list[Trade] = Field(default_factory=list)
    total_pnl: Decimal = Field(default=Decimal("0"))
    realized_pnl: Decimal = Field(default=Decimal("0"))

    def update_equity(self, prices: dict[str, Decimal]) -> None:
        """Update portfolio equity based on current prices"""
        unrealized = Decimal("0")
        for symbol, position in self.positions.items():
            if symbol in prices:
                position.update_unrealized_pnl(prices[symbol])
                unrealized += position.unrealized_pnl
        self.equity = self.cash + sum(
            pos.value for pos in self.positions.values()
        )
        self.total_pnl = self.realized_pnl + unrealized

    class Config:
        json_encoders = {
            Decimal: lambda v: float(v),
        }

